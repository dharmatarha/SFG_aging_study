function [blockIdx, stimTypes, stimTypeIdx, stimArray, trialIdx] = stim2blocksTraining(stimArrayFile, seqFeatures)
%% Helper function sorting stimuli to training sequences
%
% USAGE: [blockIdx, stimTypes, stimTypeIdx, stimArray] = 
%           stim2blocksTraining(stimArrayFile, seqFeatures=[5,6; 3,8; 4,4; 3,6; 3,4; 2,3])
%
% For training phase of stochastic figure-ground (SFG) experiment. 
% The function examines the stimuli array for unique stimuli types and 
% creates sequences containing the different types, as used for training. 
% Returns block and trial indices for each stimulus.
%
%
% Inputs:
% stimArrayFile - *.mat file with cell array "stimArray" containing all 
%               stimuli + features (size: no. of stimuli X 11 columns)
% seqFeatures   - Matrix with figure duration (column one) and coherence 
%               values (column two). Each row specifies the duration and
%               coherence values needed for sequence. Row index corresponds
%               to sequence number. Defaults the training settings used in
%               Toth et al., 2016, EEG signatures accompanying...:
%               [5,6; 3,8; 4,4; 3,6; 3,4; 2,3]
%
% Outputs:
% blockIdx      - Numeric column vector with a block index for each
%               stimulus in the stimuli array
% stimTypes     - Matrix where each line corresponds to a unique stimulus 
%               type in terms of figure duration, coherence level and 
%               figure presence/absence. Irs size is "no. of unique types" 
%               X 3, with columns corresponding to duration, coherence and
%               figure presence/absence
% stimTypeIdx   - Numeric column vector with a stimulus type index for each
%               stimulus in the stimuli array. Index numbers correspond to 
%               the rows of the stimTypes output variable 
% stimArray     - Stimulus array (cell), with the 11th column storing the
%               generated audio (two identical channels)
% trialIdx      - Numeric column vector with a trial index for each
%               stimuli, generated by randomizing the trial numbers 
%               corresponding to each block
%
% NOTES:
% Hard-coded expectation for the number of columns of stimuli array (=11)!! 
%


%% Input checks

if ~ismember(nargin, [1 2])
    error('Function needs mandatory input arg "stimArray" and optional arg "seqFeatures"!');
end
if nargin == 1
    seqFeatures = [5,6; 3,8; 4,4; 3,6; 3,4; 2,3];
end
% file with stimuli array
if ~exist(stimArrayFile, 'file')
    error('Cannot find input arg "stimArrayFile"!');
end
% number of sequences
if ~ismembertol(size(seqFeatures, 1), [1:50])
    error('Number of training sequences should be between 1 - 50!');
end

% user message
disp([char(10), 'Called stim2blocksTraining with input args: ',...
    char(10), 'stimArrayFile:', stimArrayFile,...
    char(10), 'seqFeatures: ']);
disp({'figureDuration', 'figureCoherence'});
disp(num2str(seqFeatures));


%% Loading stimuli, sanity checks

% number of stimulus blocks = number of training sequences = rows of
% seqFeatures
blockNo = size(seqFeatures, 1);

%%%%%% HARD-CODED VALUES %%%%%
% number of expected cell columns for the stimuli array
stimFeaturesNo = 11;
% header for final stimTypes cell array (see the last code block)
stimTypesHdr = {'figDuration', 'figCoherence', 'figPresence', 'stimulusTypeIndex'};
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% load stimuli
load(stimArrayFile, 'stimArray');
% sanity check - number of stimuli features
if ~isequal(size(stimArray, 2), stimFeaturesNo)
    error('Loaded stimuli array has unexpected size (no. of columns)!');
end
% get number of trials from stimuli array
trialNo = size(stimArray, 1);
% sanity check - trials/blocks == integer?
if mod(trialNo/blockNo, 1) ~= 0
    error(['Number of trials (', num2str(trialNo), ', based on stimuli',... 
        'array) is incompatible with the number of sequences (', num2str(blockNo), ') requested']);
end

% user message
disp([char(10), 'Loaded stimuli array, found ', num2str(trialNo), ' trials, ',...
    char(10), 'each stimulus block (=training sequence) will contain ', num2str(trialNo/blockNo), ' trials']);


%% Get unique stimulus types

% get number of unique stimulus types based on figure presence/absence, 
% coherence and duration
durValues = cell2mat(stimArray(:, 6));
cohValues = cell2mat(stimArray(:, 7));
figPresent = stimArray(:, 5);
% turn figPresent cell array of strings to numeric 0/1
figPresentNum = zeros(length(figPresent), 1);
figPresentNum(strcmp(figPresent, 'yes')) = 1;
% unique combinations
[stimTypes, ~, stimTypeIdx] = unique([durValues, cohValues, figPresentNum], 'rows');

% user message
disp([char(10), 'There are ', num2str(size(stimTypes, 1)),... 
    ' different trial types  in the stimuli array ',... 
    char(10), '(in terms of figure presence/absence, ',...
    'duration and coherence).'])

% check how many of each unique types we have
stimTypesNumbers = nan(size(stimTypes, 1), 1);
for i = 1:size(stimTypes, 1)
    stimTypesNumbers(i) = sum(stimTypeIdx==i);
end

% if there are different numbers for trial types, that is a problem, throw
% error, otherwise report the number per type and per type per block
if length(unique(stimTypesNumbers)) ~= 1
    disp([char(10), 'Stimulus types in terms of duration, coherence and figure presence:']);
    disp(stimTypes);
    disp('Number of trials per stimulus type:');
    disp(stimTypesNumbers);
    error('There are different numbers of trials for different trial types!');
else
    stimNoPerType = unique(stimTypesNumbers);
    disp([char(10), 'There are ', num2str(stimNoPerType), ' trials for each trial type']);
end


%% Sort stimuli into blocks

% split trials into blocks according to seqFeatures
blockIdx = nan(trialNo, 1); % block index for each stimulus
for seq = 1:blockNo
    % which unique trial types correspond to the features of the current sequence
    idx = find(ismember(stimTypes(:, 1:2), seqFeatures(seq,:),'rows'));
    % go through the unique trial types corresponding to sequence
    for t = idx'
        % assign the right block (=sequence) number to stimuli with the
        % current stimulus type
        blockIdx(stimTypeIdx==t) = seq;
    end
end

% user message
disp([char(10), 'Sorted stimuli into blocks, with equal number of trials per type per block']);


%% Get exact trial indices for stimuli, return

% expected number of stimuli per block
stimNoPerBlock = trialNo/blockNo;
% init a trial indices column vector
trialIdx = zeros(trialNo, 1);

% go through each block and generate trial indices for corresponding
% stimuli
for block = 1:blockNo
    % check if we have the expected number of trials
    if ~isequal(sum(blockIdx==block), stimNoPerBlock)
        error(['There are ', num2str(sum(blockIdx==block)),... 
            ' trials for block ', num2str(block), ' instead of ',... 
            num2str(stimNoPerBlock), ', investigate!']);
    end
    % trial indices for given block, in order
    trialIdxForBlock = [(block-1)*stimNoPerBlock+1:block*stimNoPerBlock]; 
    % randomizing trial indices for given block
    trialIdxForBlock = trialIdxForBlock(randperm(length(trialIdxForBlock)));
    % assigning the randomized trial indices to the stimuli corresponding
    % to the block
    trialIdx(blockIdx==block) = trialIdxForBlock;
end

% user message
disp([char(10), 'Randomized trial order within blocks, generated final trial indices vector']);


%% Transform stimTypes varialbe into human readable form 

% get cell array with headers
stimTypes = [stimTypesHdr; num2cell([stimTypes, [1:size(stimTypes, 1)]'])];

disp([char(10), 'Detailed information about stimulus types is stored in '...
    'the stimTypes cell array']);


return






