function [blockIdx, stimTypes, stimTypeIdx, stimArray, trialIdx] = stim2blocks(stimArrayFile, blockNo)
%% Helper function sorting stimuli to blocks and trials
%
% USAGE: [blockIdx, stimTypes, stimTypeIdx, stimArray] = stim2blocks(stimArrayFile, blockNo)
%
% For stochastic figure-ground (SFG) experiment. The function examines the
% stimuli array for unique stimuli types and creates blocks containing
% equal number of trials with each unique stimulus type. Returns block and
% trial indices for each stimulus.
%
%
% Inputs:
% stimArrayFile - *.mat file with cell array "stimArray" containing all 
%               stimuli + features (size: no. of stimuli X 11 columns)
% blockNo       - Number of blocks to sort trials into, integer between
%               1-50
%
% Outputs:
% blockIdx      - Numeric column vector with a block index for each
%               stimulus in the stimuli array
% stimTypes     - Matrix where each line corresponds to a unique stimulus 
%               type in terms of figure duration, coherence level and 
%               figure presence/absence. Irs size is "no. of unique types" 
%               X 3, with columns corresponding to duration, coherence and
%               figure presence/absence
% stimTypeIdx   - Numeric column vector with a stimulus type index for each
%               stimulus in the stimuli array. Index numbers correspond to 
%               the rows of the stimTypes output variable 
% stimArray     - Stimulus array (cell), with the 11th column storing the
%               generated audio (two identical channels)
% trialIdx      - Numeric column vector with a trial index for each
%               stimuli, generated by randomizing the trial numbers 
%               corresponding to each block
%
% NOTES:
% Hard-coded expectation for the number of columns of stimuli array (=11)!! 
%


%% Input checks

if nargin ~= 2
    error('Function needs input args "stimArray" and "blockNo"!');
end
% file with stimuli array
if ~exist(stimArrayFile, 'file')
    error('Cannot find input arg "stimArrayFile"!');
end
% number of blocks
if ~ismembertol(blockNo, 1:50)
    error('Input arg "blockNo" should be between 1 - 50!');
end

% user message
disp([char(10), 'Called stim2blocks with input args: ',...
    char(10), 'stimArrayFile:', stimArrayFile,...
    char(10), 'blockNo: ', num2str(blockNo)]);


%% Loading stimuli, sanity checks

%%%%%% HARD-CODED VALUES %%%%%
% number of expected cell columns for the stimuli array
stimFeaturesNo = 12;
% header for final stimTypes cell array (see the last code block)
stimTypesHdr = {'figDuration', 'figCoherence', 'figPresence', 'stimulusTypeIndex'};
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% load stimuli
load(stimArrayFile, 'stimArray');
% sanity check - number of stimuli features
if ~isequal(size(stimArray, 2), stimFeaturesNo)
    error('Loaded stimuli array has unexpected size (no. of columns)!');
end
% get number of trials from stimuli array
trialNo = size(stimArray, 1);
% sanity check - trials/blocks == integer?
if mod(trialNo/blockNo, 1) ~= 0
    error(['Number of trials (', num2str(trialNo), ', based on stimuli',... 
        'array) is incompatible with the number of blocks (', num2str(blockNo), ') requested']);
end

% user message
disp([char(10), 'Loaded stimuli array, found ', num2str(trialNo), ' trials, ',...
    char(10), 'each block will contain ', num2str(trialNo/blockNo), ' trials']);


%% Get unique stimulus types

% get number of unique stimulus types based on figure presence/absence, 
% coherence and duration
backgrValues = cell2mat(stimArray(:, 11));
cohValues = cell2mat(stimArray(:, 6));
figPresentNum = (cohValues~=0);

% unique combinations
[stimTypes, ~, stimTypeIdx] = unique([backgrValues, cohValues, figPresentNum], 'rows');

% user message
disp([char(10), 'There are ', num2str(size(stimTypes, 1)),... 
    ' different trial types  in the stimuli array ',... 
    char(10), '(in terms of figure presence/absence, ',...
    'duration and coherence).'])

% check how many of each unique types we have
stimTypesNumbers = nan(size(stimTypes, 1), 1);
for i = 1:size(stimTypes, 1)
    stimTypesNumbers(i) = sum(stimTypeIdx==i);
end

% if there are different numbers for trial types, that is a problem, throw
% error, otherwise report the number per type and per type per block
if length(unique(stimTypesNumbers)) ~= 1
    disp([char(10), 'Stimulus types in terms of duration, coherence and figure presence:']);
    disp(stimTypes);
    disp('Number of trials per stimulus type:');
    disp(stimTypesNumbers);
    error('There are different numbers of trials for different trial types!');
else
    stimNoPerType = unique(stimTypesNumbers);
    stimNoPerTypePerBlock = unique(stimTypesNumbers)/blockNo;
    disp([char(10), 'There are ', num2str(stimNoPerType), ' trials for each trial type, ',...
        char(10), 'corresponding to ', num2str(stimNoPerTypePerBlock), ' trials for each type per block']);
end


%% Sort stimuli into blocks

% split trials into blocks, with equal number of trials per type per block
blockIdx = nan(trialNo, 1); % block index for each stimulus
for i = 1:size(stimTypes, 1)
    typeBlockIdx = repmat(1:blockNo, [1, stimNoPerTypePerBlock]);  % init block indices array
    typeBlockIdx = typeBlockIdx(randperm(length(typeBlockIdx)));  % permute its values
    blockIdx(stimTypeIdx==i) = typeBlockIdx;  % assign block indices to stimuli corresponding to current type
end

% user message
disp([char(10), 'Sorted stimuli into blocks, with equal number of trials per type per block']);


%% Get exact trial indices for stimuli, return

% number of stimuli per block
stimNoPerBlock = size(stimTypes, 1)*stimNoPerTypePerBlock;
% init a trial indices column vector
trialIdx = zeros(trialNo, 1);

% go through each block and generate trial indices for corresponding
% stimuli
for block = 1:blockNo
    % trial indices for given block, in order
    trialIdxForBlock = [(block-1)*stimNoPerBlock+1:block*stimNoPerBlock]; 
    % randomizing trial indices for given block
    trialIdxForBlock = trialIdxForBlock(randperm(length(trialIdxForBlock)));
    % assigning the randomized trial indices to the stimuli corresponding
    % to the block
    trialIdx(blockIdx==block) = trialIdxForBlock;
end

% user message
disp([char(10), 'Randomized trial order within blocks, generated final trial indices vector']);


%% Transform stimTypes varialbe into human readable form 

% get cell array with headers
stimTypes = [stimTypesHdr; num2cell([stimTypes, [1:size(stimTypes, 1)]'])];

disp([char(10), 'Detailed information about stimulus types is stored in '...
    'the stimTypes cell array']);


return






